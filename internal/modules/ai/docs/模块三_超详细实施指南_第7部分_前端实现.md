# æ¨¡å—ä¸‰ï¼šAI å¾®æœåŠ¡/å°å·¥å…· - è¶…è¯¦ç»†å®æ–½æŒ‡å—

## ç¬¬ 7 éƒ¨åˆ†ï¼šå‰ç«¯å®ç°

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2026-02-09  
> **é€‚ç”¨èŒƒå›´**: OmniLink Vue3 å‰ç«¯ - AI å¾®æœåŠ¡äº¤äº’å±‚  
> **ä¾èµ–éƒ¨åˆ†**: Part 4 Handler å±‚, Part 5 è·¯ç”±é…ç½®

---

## ğŸ“š ç›®å½•

1. [æ¦‚è¿°](#1-æ¦‚è¿°)
2. [API æœåŠ¡å±‚](#2-api-æœåŠ¡å±‚)
3. [WebSocket æœåŠ¡](#3-websocket-æœåŠ¡)
4. [ç»„ä»¶å®ç°](#4-ç»„ä»¶å®ç°)
   - [4.1 æ™ºèƒ½è¾“å…¥ç»„ä»¶](#41-æ™ºèƒ½è¾“å…¥ç»„ä»¶)
   - [4.2 æ¶¦è‰²æŒ‰é’®ç»„ä»¶](#42-æ¶¦è‰²æŒ‰é’®ç»„ä»¶)
   - [4.3 æ‘˜è¦å¡ç‰‡ç»„ä»¶](#43-æ‘˜è¦å¡ç‰‡ç»„ä»¶)
5. [çŠ¶æ€ç®¡ç†](#5-çŠ¶æ€ç®¡ç†)
6. [æ ·å¼è®¾è®¡](#6-æ ·å¼è®¾è®¡)
7. [æµ‹è¯•æ–¹æ¡ˆ](#7-æµ‹è¯•æ–¹æ¡ˆ)

---

## 1. æ¦‚è¿°

### 1.1 å‰ç«¯æ¶æ„

```
web/src/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ aiMicroservice.js          # HTTP API å°è£…ï¼ˆpolish, digestï¼‰
â”œâ”€â”€ services/
â”‚   â””â”€â”€ InputPredictionService.js  # WebSocket è¿æ¥ç®¡ç†ï¼ˆinput_predictionï¼‰
â”œâ”€â”€ components/chat/
â”‚   â”œâ”€â”€ ChatInput.vue              # æ™ºèƒ½è¾“å…¥æ¡†ï¼ˆé›†æˆé¢„æµ‹åŠŸèƒ½ï¼‰
â”‚   â”œâ”€â”€ PolishButtons.vue          # æ¶¦è‰²é€‰é¡¹æŒ‰é’®ç»„
â”‚   â””â”€â”€ DigestCard.vue             # æ¶ˆæ¯æ‘˜è¦å¡ç‰‡
â””â”€â”€ store/modules/
    â””â”€â”€ aiMicroservice.js          # Vuex çŠ¶æ€ç®¡ç†
```

### 1.2 æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|
| Vue 3 | 3.3+ | ç»„åˆå¼ APIï¼ˆComposition APIï¼‰ |
| Vuex | 4.x | å…¨å±€çŠ¶æ€ç®¡ç† |
| Axios | 1.x | HTTP è¯·æ±‚ |
| WebSocket API | åŸç”Ÿ | å®æ—¶é€šä¿¡ï¼ˆè¾“å…¥é¢„æµ‹ï¼‰ |
| Element Plus | 2.x | UI ç»„ä»¶åº“ï¼ˆButtonã€Message ç­‰ï¼‰ |
| Lodash | 4.x | å·¥å…·å‡½æ•°ï¼ˆdebounceï¼‰ |

### 1.3 äº¤äº’æµç¨‹

#### æµç¨‹ 1ï¼šæ™ºèƒ½è¾“å…¥é¢„æµ‹

```
ç”¨æˆ·è¾“å…¥ â†’ (500ms debounce) â†’ WebSocket å‘é€ â†’ åç«¯æµå¼è¿”å› â†’ åŠé€æ˜æ–‡æœ¬æ¸²æŸ“ â†’ ç”¨æˆ·æŒ‰ Tab è¡¥å…¨
```

#### æµç¨‹ 2ï¼šæ–‡æœ¬æ¶¦è‰²

```
ç”¨æˆ·è¾“å…¥å®Œæˆ â†’ è‡ªåŠ¨è°ƒç”¨ polish API â†’ è§£æ JSON å“åº” â†’ æ¸²æŸ“æ¶¦è‰²æŒ‰é’® â†’ ç”¨æˆ·ç‚¹å‡» â†’ æ›¿æ¢è¾“å…¥æ¡†æ–‡æœ¬
```

#### æµç¨‹ 3ï¼šæ¶ˆæ¯æ‘˜è¦

```
ç¾¤èŠæ¶ˆæ¯è¶… 50 æ¡ â†’ æ˜¾ç¤º"æŸ¥çœ‹æ‘˜è¦"æŒ‰é’® â†’ ç”¨æˆ·ç‚¹å‡» â†’ è°ƒç”¨ digest API â†’ æ¸²æŸ“ Markdown æ‘˜è¦å¡ç‰‡
```

---

## 2. API æœåŠ¡å±‚

### 2.1 ä»£ç å®ç°

**æ–‡ä»¶è·¯å¾„**: `web/src/api/aiMicroservice.js`ï¼ˆæ–°å»ºï¼‰

```javascript
/**
 * AI å¾®æœåŠ¡ API å°è£…
 * åŒ…å«ï¼šæ–‡æœ¬æ¶¦è‰²ã€æ¶ˆæ¯æ‘˜è¦åŠŸèƒ½
 * ï¼ˆæ™ºèƒ½è¾“å…¥é¢„æµ‹ä½¿ç”¨ WebSocketï¼Œè§ services/InputPredictionService.jsï¼‰
 */

import request from '@/utils/request' // å‡è®¾å·²æœ‰ Axios å°è£…

/**
 * æ–‡æœ¬æ¶¦è‰² - è·å–å¤šç§é£æ ¼æ”¹å†™å»ºè®®
 * @param {Object} params
 * @param {string} params.user_input - ç”¨æˆ·åŸæ–‡
 * @param {string} params.session_id - ä¼šè¯ IDï¼ˆå¯é€‰ï¼‰
 * @param {Array<Object>} params.context_messages - ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰
 * @returns {Promise<Object>} { options: [{style: string, text: string}] }
 */
export function polishText(params) {
  return request({
    url: '/ai/microservice/polish',
    method: 'post',
    data: {
      user_input: params.user_input,
      session_id: params.session_id || '',
      context_messages: params.context_messages || []
    },
    timeout: 15000 // 15ç§’è¶…æ—¶
  })
}

/**
 * æ¶ˆæ¯æ‘˜è¦ - ç”Ÿæˆç¾¤èŠè®°å½•ç»“æ„åŒ–æ‘˜è¦
 * @param {Object} params
 * @param {string} params.session_id - ä¼šè¯ ID
 * @param {Array<Object>} params.messages - æ¶ˆæ¯åˆ—è¡¨
 *   æ¯ä¸ªæ¶ˆæ¯æ ¼å¼ï¼š{ sender: string, content: string, timestamp: number }
 * @param {number} params.max_messages - æœ€å¤šå¤„ç†æ¶ˆæ¯æ•°ï¼ˆé»˜è®¤ 200ï¼‰
 * @returns {Promise<Object>} { summary: string (Markdown æ ¼å¼) }
 */
export function digestMessages(params) {
  return request({
    url: '/ai/microservice/digest',
    method: 'post',
    data: {
      session_id: params.session_id,
      messages: params.messages,
      max_messages: params.max_messages || 200
    },
    timeout: 20000 // 20ç§’è¶…æ—¶ï¼ˆå¤„ç†é•¿æ–‡æœ¬ï¼‰
  })
}

/**
 * æ™ºèƒ½è¾“å…¥é¢„æµ‹ - HTTP ç‰ˆæœ¬ï¼ˆç”¨äºæµ‹è¯•ï¼Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨ WebSocketï¼‰
 * @param {Object} params
 * @param {string} params.user_input - ç”¨æˆ·å½“å‰è¾“å…¥
 * @param {string} params.session_id - ä¼šè¯ ID
 * @param {Array<Object>} params.context_messages - ä¸Šä¸‹æ–‡æ¶ˆæ¯
 * @returns {Promise<Object>} { prediction: string }
 */
export function predictInput(params) {
  return request({
    url: '/ai/microservice/predict',
    method: 'post',
    data: {
      user_input: params.user_input,
      session_id: params.session_id || '',
      context_messages: params.context_messages || []
    },
    timeout: 5000
  })
}
```

### 2.2 ä»£ç è§£é‡Š

**ç¬¬ 1-6 è¡Œ**ï¼šæ–‡æ¡£æ³¨é‡Š
```javascript
/**
 * AI å¾®æœåŠ¡ API å°è£…
 * åŒ…å«ï¼šæ–‡æœ¬æ¶¦è‰²ã€æ¶ˆæ¯æ‘˜è¦åŠŸèƒ½
 * ï¼ˆæ™ºèƒ½è¾“å…¥é¢„æµ‹ä½¿ç”¨ WebSocketï¼Œè§ services/InputPredictionService.jsï¼‰
 */
```
- æ˜ç¡®è¯´æ˜ WebSocket åŠŸèƒ½åœ¨ç‹¬ç«‹æ–‡ä»¶ä¸­
- JSDoc æ³¨é‡Šæ”¯æŒ IDE è‡ªåŠ¨è¡¥å…¨

**ç¬¬ 8 è¡Œ**ï¼šå¯¼å…¥ Axios å°è£…
```javascript
import request from '@/utils/request'
```
- å‡è®¾é¡¹ç›®å·²æœ‰ç»Ÿä¸€çš„ Axios å®ä¾‹ï¼ˆåŒ…å« baseURLã€æ‹¦æˆªå™¨ã€JWT token æ³¨å…¥ï¼‰
- è‹¥æ— ï¼Œéœ€æ‰‹åŠ¨åˆ›å»ºï¼š
  ```javascript
  import axios from 'axios'
  const request = axios.create({
    baseURL: process.env.VUE_APP_API_BASE_URL || 'http://localhost:8080',
    timeout: 10000,
    headers: { 'Content-Type': 'application/json' }
  })
  // æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨ï¼ˆæ³¨å…¥ JWT tokenï¼‰
  request.interceptors.request.use(config => {
    const token = localStorage.getItem('access_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  })
  ```

**ç¬¬ 10-25 è¡Œ**ï¼špolishText å‡½æ•°
```javascript
export function polishText(params) {
  return request({
    url: '/ai/microservice/polish',
    method: 'post',
    data: {
      user_input: params.user_input,
      session_id: params.session_id || '',
      context_messages: params.context_messages || []
    },
    timeout: 15000
  })
}
```
- **è¶…æ—¶è®¾ç½®**ï¼š`timeout: 15000`ï¼ˆ15 ç§’ï¼‰
  - åŸå› ï¼špolish éœ€è¦è°ƒç”¨ LLM + è§£æ JSONï¼Œè€—æ—¶è¾ƒé•¿
  - è‹¥è¶…æ—¶ï¼Œå‰ç«¯åº”æ˜¾ç¤ºå‹å¥½æç¤ºï¼š"æ¶¦è‰²æœåŠ¡å“åº”è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•"
- **é»˜è®¤å€¼å¤„ç†**ï¼š`session_id || ''` é˜²æ­¢ä¼ å…¥ `undefined` å¯¼è‡´åç«¯æŠ¥é”™
- **è¿”å›å€¼**ï¼šç›´æ¥è¿”å› Promiseï¼Œç”±è°ƒç”¨æ–¹ `.then()` æˆ– `await` å¤„ç†

**ç¬¬ 27-44 è¡Œ**ï¼šdigestMessages å‡½æ•°
```javascript
export function digestMessages(params) {
  return request({
    url: '/ai/microservice/digest',
    method: 'post',
    data: {
      session_id: params.session_id,
      messages: params.messages,
      max_messages: params.max_messages || 200
    },
    timeout: 20000  // 20ç§’è¶…æ—¶
  })
}
```
- **æ›´é•¿è¶…æ—¶**ï¼š`timeout: 20000`ï¼ˆ20 ç§’ï¼‰
  - åŸå› ï¼šæ‘˜è¦éœ€è¦å¤„ç†æœ€å¤š 200 æ¡æ¶ˆæ¯ï¼Œä½¿ç”¨é•¿ä¸Šä¸‹æ–‡æ¨¡å‹ï¼ˆdoubao-pro-32kï¼‰
- **æ¶ˆæ¯æ ¼å¼çº¦å®š**ï¼š
  ```javascript
  params.messages = [
    { sender: 'å¼ ä¸‰', content: 'ä»Šå¤©å¤©æ°”ä¸é”™', timestamp: 1707500000 },
    { sender: 'æå››', content: 'æ˜¯å•Šï¼Œé€‚åˆå‡ºé—¨', timestamp: 1707500010 }
  ]
  ```
- **è¿”å›æ ¼å¼**ï¼š
  ```javascript
  {
    summary: "**ä¸»é¢˜1ï¼šå¤©æ°”è®¨è®º**\n- å‚ä¸è€…ï¼š@å¼ ä¸‰ã€@æå››\n- æ ¸å¿ƒå†…å®¹ï¼š..."
  }
  ```

**ç¬¬ 46-60 è¡Œ**ï¼špredictInput å‡½æ•°ï¼ˆHTTP ç‰ˆæœ¬ï¼‰
```javascript
export function predictInput(params) {
  return request({
    url: '/ai/microservice/predict',
    method: 'post',
    data: { /* ... */ },
    timeout: 5000
  })
}
```
- **ç”¨é€”**ï¼šä»…ç”¨äºæµ‹è¯•æˆ–é™çº§åœºæ™¯
- **ç”Ÿäº§ç¯å¢ƒ**ï¼šåº”ä½¿ç”¨ WebSocket å®ç°æµå¼é¢„æµ‹ï¼ˆè§ä¸‹ä¸€èŠ‚ï¼‰
- **è¶…æ—¶è®¾ç½®**ï¼š`timeout: 5000`ï¼ˆ5 ç§’ï¼‰
  - åŸå› ï¼šinput_prediction ä½¿ç”¨å°æ¨¡å‹ï¼ˆdoubao-lite-8kï¼‰ï¼Œå“åº”å¿«

---

## 3. WebSocket æœåŠ¡

### 3.1 ä»£ç å®ç°

**æ–‡ä»¶è·¯å¾„**: `web/src/services/InputPredictionService.js`ï¼ˆæ–°å»ºï¼‰

```javascript
/**
 * æ™ºèƒ½è¾“å…¥é¢„æµ‹ - WebSocket æœåŠ¡
 * ç®¡ç† WebSocket è¿æ¥ã€æ¶ˆæ¯å‘é€ã€æµå¼æ¥æ”¶ã€æ–­çº¿é‡è¿
 */

import { ElMessage } from 'element-plus'

class InputPredictionService {
  constructor() {
    this.ws = null                  // WebSocket å®ä¾‹
    this.isConnected = false        // è¿æ¥çŠ¶æ€
    this.reconnectAttempts = 0      // é‡è¿å°è¯•æ¬¡æ•°
    this.maxReconnectAttempts = 5   // æœ€å¤§é‡è¿æ¬¡æ•°
    this.reconnectInterval = 2000   // é‡è¿é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    this.messageHandlers = []       // æ¶ˆæ¯å›è°ƒé˜Ÿåˆ—
    this.connectionPromise = null   // è¿æ¥ Promiseï¼ˆé¿å…é‡å¤è¿æ¥ï¼‰
  }

  /**
   * å»ºç«‹ WebSocket è¿æ¥
   * @param {string} token - JWT token
   * @returns {Promise<void>}
   */
  connect(token) {
    // å·²è¿æ¥ï¼Œç›´æ¥è¿”å›
    if (this.isConnected && this.ws?.readyState === WebSocket.OPEN) {
      return Promise.resolve()
    }

    // æ­£åœ¨è¿æ¥ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promise
    if (this.connectionPromise) {
      return this.connectionPromise
    }

    this.connectionPromise = new Promise((resolve, reject) => {
      try {
        // æ„é€  WebSocket URLï¼ˆå¸¦ token å‚æ•°ï¼‰
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
        const wsHost = process.env.VUE_APP_WS_HOST || window.location.host
        const wsUrl = `${wsProtocol}//${wsHost}/ai/microservice/input/ws?token=${token}`

        this.ws = new WebSocket(wsUrl)

        // è¿æ¥æˆåŠŸ
        this.ws.onopen = () => {
          console.log('[InputPrediction] WebSocket connected')
          this.isConnected = true
          this.reconnectAttempts = 0
          this.connectionPromise = null
          resolve()
        }

        // æ¥æ”¶æ¶ˆæ¯
        this.ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data)
            
            // é”™è¯¯æ¶ˆæ¯
            if (data.error) {
              console.error('[InputPrediction] Server error:', data.error)
              ElMessage.error(`é¢„æµ‹å¤±è´¥: ${data.error}`)
              return
            }

            // æµå¼æ•°æ®
            if (data.chunk) {
              this._notifyHandlers({ type: 'chunk', data: data.chunk })
            }

            // å®Œæˆæ ‡è®°
            if (data.done) {
              this._notifyHandlers({ type: 'done' })
            }
          } catch (err) {
            console.error('[InputPrediction] Failed to parse message:', err)
          }
        }

        // è¿æ¥å…³é—­
        this.ws.onclose = (event) => {
          console.log('[InputPrediction] WebSocket closed:', event.code, event.reason)
          this.isConnected = false
          this.connectionPromise = null

          // éæ­£å¸¸å…³é—­ï¼Œå°è¯•é‡è¿
          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++
            console.log(`[InputPrediction] Reconnecting (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`)
            setTimeout(() => {
              this.connect(token)
            }, this.reconnectInterval)
          } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            ElMessage.error('æ™ºèƒ½è¾“å…¥æœåŠ¡è¿æ¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•')
          }
        }

        // è¿æ¥é”™è¯¯
        this.ws.onerror = (error) => {
          console.error('[InputPrediction] WebSocket error:', error)
          this.connectionPromise = null
          reject(error)
        }
      } catch (err) {
        this.connectionPromise = null
        reject(err)
      }
    })

    return this.connectionPromise
  }

  /**
   * å‘é€é¢„æµ‹è¯·æ±‚
   * @param {Object} params
   * @param {string} params.user_input - ç”¨æˆ·å½“å‰è¾“å…¥
   * @param {string} params.session_id - ä¼šè¯ ID
   * @param {Array<Object>} params.context_messages - ä¸Šä¸‹æ–‡æ¶ˆæ¯
   * @param {Function} onChunk - æ¥æ”¶æµå¼æ•°æ®å›è°ƒ (chunk: string) => void
   * @param {Function} onDone - å®Œæˆå›è°ƒ () => void
   */
  predict({ user_input, session_id, context_messages }, onChunk, onDone) {
    if (!this.isConnected || this.ws?.readyState !== WebSocket.OPEN) {
      console.warn('[InputPrediction] WebSocket not connected, skipping prediction')
      return
    }

    // æ³¨å†Œå›è°ƒ
    const handlerId = Date.now() + Math.random()
    this.messageHandlers.push({
      id: handlerId,
      onChunk,
      onDone
    })

    // å‘é€è¯·æ±‚
    const payload = {
      user_input,
      session_id: session_id || '',
      context_messages: context_messages || []
    }

    try {
      this.ws.send(JSON.stringify(payload))
    } catch (err) {
      console.error('[InputPrediction] Failed to send message:', err)
      // ç§»é™¤å¤±è´¥çš„ handler
      this.messageHandlers = this.messageHandlers.filter(h => h.id !== handlerId)
    }
  }

  /**
   * é€šçŸ¥æ‰€æœ‰æ¶ˆæ¯å¤„ç†å™¨
   * @private
   */
  _notifyHandlers(message) {
    this.messageHandlers.forEach(handler => {
      if (message.type === 'chunk' && handler.onChunk) {
        handler.onChunk(message.data)
      } else if (message.type === 'done' && handler.onDone) {
        handler.onDone()
      }
    })

    // å®Œæˆåæ¸…ç©º handlers
    if (message.type === 'done') {
      this.messageHandlers = []
    }
  }

  /**
   * å…³é—­è¿æ¥
   */
  disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect') // 1000 = æ­£å¸¸å…³é—­
      this.ws = null
      this.isConnected = false
      this.messageHandlers = []
    }
  }
}

// å•ä¾‹æ¨¡å¼
export default new InputPredictionService()
```

### 3.2 ä»£ç è§£é‡Š

**ç¬¬ 8-17 è¡Œ**ï¼šç±»æ„é€ å‡½æ•°
```javascript
constructor() {
  this.ws = null
  this.isConnected = false
  this.reconnectAttempts = 0
  this.maxReconnectAttempts = 5
  this.reconnectInterval = 2000
  this.messageHandlers = []
  this.connectionPromise = null
}
```
- **å•ä¾‹æ¨¡å¼**ï¼šæ•´ä¸ªåº”ç”¨å…±äº«ä¸€ä¸ª WebSocket è¿æ¥
- **é‡è¿æœºåˆ¶**ï¼šæœ€å¤šå°è¯• 5 æ¬¡ï¼Œæ¯æ¬¡é—´éš” 2 ç§’
- **æ¶ˆæ¯é˜Ÿåˆ—**ï¼š`messageHandlers` å­˜å‚¨å¤šä¸ªå›è°ƒï¼ˆæ”¯æŒå¹¶å‘é¢„æµ‹ï¼Œè™½ç„¶å®é™…åœºæ™¯ä¸­ç”¨æˆ·åŒæ—¶åªè¾“å…¥ä¸€ä¸ªæ¡†ï¼‰

**ç¬¬ 19-32 è¡Œ**ï¼šè¿æ¥å»é‡
```javascript
connect(token) {
  // å·²è¿æ¥ï¼Œç›´æ¥è¿”å›
  if (this.isConnected && this.ws?.readyState === WebSocket.OPEN) {
    return Promise.resolve()
  }

  // æ­£åœ¨è¿æ¥ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promise
  if (this.connectionPromise) {
    return this.connectionPromise
  }
  // ...
}
```
- **å¹‚ç­‰æ€§ä¿è¯**ï¼šå¤šæ¬¡è°ƒç”¨ `connect()` ä¸ä¼šåˆ›å»ºå¤šä¸ªè¿æ¥
- **Promise ç¼“å­˜**ï¼šæ­£åœ¨è¿æ¥æ—¶è¿”å›åŒä¸€ä¸ª Promiseï¼Œé¿å…ç«æ€æ¡ä»¶

**ç¬¬ 38-42 è¡Œ**ï¼šWebSocket URL æ„é€ 
```javascript
const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
const wsHost = process.env.VUE_APP_WS_HOST || window.location.host
const wsUrl = `${wsProtocol}//${wsHost}/ai/microservice/input/ws?token=${token}`
```
- **åè®®è‡ªé€‚åº”**ï¼šHTTPS é¡µé¢ä½¿ç”¨ `wss://`ï¼ŒHTTP ä½¿ç”¨ `ws://`
- **ç¯å¢ƒå˜é‡æ”¯æŒ**ï¼š`VUE_APP_WS_HOST` å¯è¦†ç›–é»˜è®¤ hostï¼ˆç”¨äºå¼€å‘ç¯å¢ƒè·¨åŸŸï¼‰
  - ç¤ºä¾‹ï¼š`.env.development` ä¸­è®¾ç½® `VUE_APP_WS_HOST=localhost:8080`
- **Token ä¼ é€’**ï¼šé€šè¿‡ URL å‚æ•°ä¼ é€’ JWTï¼ˆåç«¯ `ws_auth.go` ä¸­é—´ä»¶æ ¡éªŒï¼‰

**ç¬¬ 48-54 è¡Œ**ï¼šonopen å¤„ç†
```javascript
this.ws.onopen = () => {
  console.log('[InputPrediction] WebSocket connected')
  this.isConnected = true
  this.reconnectAttempts = 0         // é‡ç½®é‡è¿è®¡æ•°
  this.connectionPromise = null      // æ¸…ç©º Promise ç¼“å­˜
  resolve()
}
```
- **çŠ¶æ€æ›´æ–°**ï¼š`isConnected = true` å…è®¸å‘é€æ¶ˆæ¯
- **é‡è¿è®¡æ•°é‡ç½®**ï¼šè¿æ¥æˆåŠŸåæ¸…é›¶ï¼Œä¸ºä¸‹æ¬¡æ–­çº¿é‡è¿åšå‡†å¤‡

**ç¬¬ 56-76 è¡Œ**ï¼šonmessage å¤„ç†ï¼ˆæµå¼æ•°æ®ï¼‰
```javascript
this.ws.onmessage = (event) => {
  try {
    const data = JSON.parse(event.data)
    
    // é”™è¯¯æ¶ˆæ¯
    if (data.error) {
      console.error('[InputPrediction] Server error:', data.error)
      ElMessage.error(`é¢„æµ‹å¤±è´¥: ${data.error}`)
      return
    }

    // æµå¼æ•°æ®
    if (data.chunk) {
      this._notifyHandlers({ type: 'chunk', data: data.chunk })
    }

    // å®Œæˆæ ‡è®°
    if (data.done) {
      this._notifyHandlers({ type: 'done' })
    }
  } catch (err) {
    console.error('[InputPrediction] Failed to parse message:', err)
  }
}
```
- **æ¶ˆæ¯æ ¼å¼**ï¼š
  ```javascript
  // æµå¼ chunk
  { "chunk": "ä½ å¥½" }
  { "chunk": "ï¼Œæœ‰ä»€ä¹ˆ" }
  { "chunk": "å¯ä»¥å¸®åŠ©ä½ çš„ï¼Ÿ" }
  { "done": true }
  
  // é”™è¯¯æ¶ˆæ¯
  { "error": "context too long" }
  ```
- **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨ Element Plus çš„ `ElMessage` æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º

**ç¬¬ 78-97 è¡Œ**ï¼šonclose å¤„ç†ï¼ˆæ–­çº¿é‡è¿ï¼‰
```javascript
this.ws.onclose = (event) => {
  console.log('[InputPrediction] WebSocket closed:', event.code, event.reason)
  this.isConnected = false
  this.connectionPromise = null

  // éæ­£å¸¸å…³é—­ï¼Œå°è¯•é‡è¿
  if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
    this.reconnectAttempts++
    console.log(`[InputPrediction] Reconnecting (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`)
    setTimeout(() => {
      this.connect(token)
    }, this.reconnectInterval)
  } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
    ElMessage.error('æ™ºèƒ½è¾“å…¥æœåŠ¡è¿æ¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•')
  }
}
```
- **æ­£å¸¸å…³é—­æ£€æµ‹**ï¼š`event.code === 1000` è¡¨ç¤ºå®¢æˆ·ç«¯ä¸»åŠ¨å…³é—­ï¼ˆå¦‚ç”¨æˆ·ç™»å‡ºï¼‰ï¼Œä¸é‡è¿
- **æŒ‡æ•°é€€é¿**ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰ï¼šå½“å‰æ¯æ¬¡é—´éš”å›ºå®š 2 ç§’ï¼Œå¯æ”¹ä¸º `2^reconnectAttempts * 1000` é€æ­¥å»¶é•¿
- **ç”¨æˆ·æç¤º**ï¼šé‡è¿å¤±è´¥ 5 æ¬¡åæç¤ºåˆ·æ–°é¡µé¢

**ç¬¬ 111-145 è¡Œ**ï¼špredict æ–¹æ³•
```javascript
predict({ user_input, session_id, context_messages }, onChunk, onDone) {
  if (!this.isConnected || this.ws?.readyState !== WebSocket.OPEN) {
    console.warn('[InputPrediction] WebSocket not connected, skipping prediction')
    return
  }

  // æ³¨å†Œå›è°ƒ
  const handlerId = Date.now() + Math.random()
  this.messageHandlers.push({
    id: handlerId,
    onChunk,
    onDone
  })

  // å‘é€è¯·æ±‚
  const payload = {
    user_input,
    session_id: session_id || '',
    context_messages: context_messages || []
  }

  try {
    this.ws.send(JSON.stringify(payload))
  } catch (err) {
    console.error('[InputPrediction] Failed to send message:', err)
    this.messageHandlers = this.messageHandlers.filter(h => h.id !== handlerId)
  }
}
```
- **çŠ¶æ€æ£€æŸ¥**ï¼šå‘é€å‰æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼Œé¿å…æŠ›å‡ºå¼‚å¸¸
- **å›è°ƒæ³¨å†Œ**ï¼šæ¯æ¬¡é¢„æµ‹æ³¨å†Œæ–°çš„ `onChunk`/`onDone` å›è°ƒ
- **Handler ID**ï¼šä½¿ç”¨æ—¶é—´æˆ³ + éšæœºæ•°ç”Ÿæˆå”¯ä¸€ IDï¼ˆè™½ç„¶å½“å‰å®ç°ä¸­æœªç”¨åˆ°ï¼Œä¸ºæœªæ¥æ‰©å±•é¢„ç•™ï¼‰

**ç¬¬ 147-162 è¡Œ**ï¼š_notifyHandlers æ–¹æ³•
```javascript
_notifyHandlers(message) {
  this.messageHandlers.forEach(handler => {
    if (message.type === 'chunk' && handler.onChunk) {
      handler.onChunk(message.data)
    } else if (message.type === 'done' && handler.onDone) {
      handler.onDone()
    }
  })

  // å®Œæˆåæ¸…ç©º handlers
  if (message.type === 'done') {
    this.messageHandlers = []
  }
}
```
- **å¹¿æ’­æ¨¡å¼**ï¼šé€šçŸ¥æ‰€æœ‰æ³¨å†Œçš„ handlerï¼ˆå½“å‰å®ç°ä¸­åŒæ—¶åªæœ‰ä¸€ä¸ªï¼Œä½†æ¶æ„æ”¯æŒå¤šä¸ªï¼‰
- **è‡ªåŠ¨æ¸…ç†**ï¼šæ”¶åˆ° `done` æ¶ˆæ¯åæ¸…ç©º handlersï¼Œé¿å…å†…å­˜æ³„æ¼

**ç¬¬ 164-174 è¡Œ**ï¼šdisconnect æ–¹æ³•
```javascript
disconnect() {
  if (this.ws) {
    this.ws.close(1000, 'Client disconnect')  // 1000 = æ­£å¸¸å…³é—­ç 
    this.ws = null
    this.isConnected = false
    this.messageHandlers = []
  }
}
```
- **è°ƒç”¨æ—¶æœº**ï¼šç”¨æˆ·ç™»å‡ºã€åˆ‡æ¢ä¼šè¯ã€ç»„ä»¶é”€æ¯ï¼ˆ`onBeforeUnmount`ï¼‰
- **çŠ¶æ€ç  1000**ï¼šå‘Šè¯‰æœåŠ¡ç«¯è¿™æ˜¯æ­£å¸¸å…³é—­ï¼Œä¸è§¦å‘åç«¯çš„å¼‚å¸¸æ—¥å¿—

**ç¬¬ 177-178 è¡Œ**ï¼šå•ä¾‹å¯¼å‡º
```javascript
export default new InputPredictionService()
```
- **ä½¿ç”¨æ–¹å¼**ï¼š
  ```javascript
  import InputPredictionService from '@/services/InputPredictionService'
  
  // å»ºç«‹è¿æ¥
  await InputPredictionService.connect(token)
  
  // å‘é€é¢„æµ‹è¯·æ±‚
  InputPredictionService.predict(
    { user_input: 'ä½ å¥½', session_id: 'sess_123', context_messages: [] },
    (chunk) => { console.log('æ”¶åˆ°chunk:', chunk) },
    () => { console.log('é¢„æµ‹å®Œæˆ') }
  )
  ```

---

## 4. ç»„ä»¶å®ç°

### 4.1 æ™ºèƒ½è¾“å…¥ç»„ä»¶

**æ–‡ä»¶è·¯å¾„**: `web/src/components/chat/ChatInput.vue`ï¼ˆä¿®æ”¹ç°æœ‰æ–‡ä»¶ï¼‰

```vue
<template>
  <div class="chat-input-wrapper">
    <!-- è¾“å…¥æ¡†åŒºåŸŸ -->
    <div class="input-container">
      <!-- åŠé€æ˜é¢„æµ‹æ–‡æœ¬å±‚ï¼ˆç»å¯¹å®šä½è¦†ç›–åœ¨ textarea ä¸Šæ–¹ï¼‰ -->
      <div 
        v-if="prediction" 
        class="prediction-overlay"
        :style="{ 
          top: textareaRect.top + 'px',
          left: textareaRect.left + 'px',
          width: textareaRect.width + 'px',
          height: textareaRect.height + 'px'
        }"
      >
        <!-- ç”¨æˆ·å·²è¾“å…¥çš„æ–‡æœ¬ï¼ˆé€æ˜å ä½ï¼‰ -->
        <span class="user-text-placeholder">{{ userInput }}</span>
        <!-- é¢„æµ‹æ–‡æœ¬ï¼ˆåŠé€æ˜ç°è‰²ï¼‰ -->
        <span class="prediction-text">{{ prediction }}</span>
      </div>

      <!-- å®é™…è¾“å…¥æ¡† -->
      <textarea
        ref="textareaRef"
        v-model="userInput"
        class="message-textarea"
        placeholder="è¾“å…¥æ¶ˆæ¯... (Tab æ¥å—å»ºè®®)"
        @input="onInput"
        @keydown="onKeyDown"
        @focus="onFocus"
        @blur="onBlur"
      />
    </div>

    <!-- æ¶¦è‰²æŒ‰é’®ï¼ˆä»…åœ¨æœ‰å®Œæ•´å¥å­æ—¶æ˜¾ç¤ºï¼‰ -->
    <PolishButtons 
      v-if="showPolishButtons"
      :options="polishOptions"
      :loading="polishLoading"
      @select="onPolishSelect"
    />

    <!-- å‘é€æŒ‰é’® -->
    <button 
      class="send-button" 
      :disabled="!userInput.trim()"
      @click="sendMessage"
    >
      å‘é€
    </button>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onBeforeUnmount, nextTick } from 'vue'
import { debounce } from 'lodash-es'
import { useStore } from 'vuex'
import InputPredictionService from '@/services/InputPredictionService'
import { polishText } from '@/api/aiMicroservice'
import PolishButtons from './PolishButtons.vue'

const store = useStore()
const props = defineProps({
  sessionId: {
    type: String,
    required: true
  }
})

const emit = defineEmits(['send'])

// ============ çŠ¶æ€ç®¡ç† ============
const userInput = ref('')           // ç”¨æˆ·è¾“å…¥
const prediction = ref('')          // é¢„æµ‹æ–‡æœ¬
const textareaRef = ref(null)       // textarea DOM å¼•ç”¨
const textareaRect = ref({          // textarea ä½ç½®ä¿¡æ¯
  top: 0,
  left: 0,
  width: 0,
  height: 0
})

const polishOptions = ref([])       // æ¶¦è‰²é€‰é¡¹
const polishLoading = ref(false)
const showPolishButtons = computed(() => {
  // å½“ç”¨æˆ·è¾“å…¥å®Œæ•´å¥å­ï¼ˆä»¥å¥å·/é—®å·/æ„Ÿå¹å·ç»“å°¾ï¼‰ä¸”ä¸ä¸ºç©ºæ—¶æ˜¾ç¤º
  const trimmed = userInput.value.trim()
  return trimmed.length > 0 && /[ã€‚ï¼Ÿï¼.?!]$/.test(trimmed) && polishOptions.value.length > 0
})

// ============ æ™ºèƒ½è¾“å…¥é¢„æµ‹ ============
// é˜²æŠ–å‡½æ•°ï¼š500ms æ— è¾“å…¥åè§¦å‘é¢„æµ‹
const debouncedPredict = debounce(() => {
  const input = userInput.value.trim()
  
  // è¾“å…¥ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œæ¸…ç©ºé¢„æµ‹
  if (input.length < 2) {
    prediction.value = ''
    return
  }

  // è·å–ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆæœ€è¿‘ 10 æ¡ï¼‰
  const contextMessages = store.getters['chat/getRecentMessages'](props.sessionId, 10)

  // å‘é€ WebSocket é¢„æµ‹è¯·æ±‚
  let accumulatedPrediction = ''
  InputPredictionService.predict(
    {
      user_input: input,
      session_id: props.sessionId,
      context_messages: contextMessages
    },
    // onChunk: æµå¼æ¥æ”¶é¢„æµ‹æ–‡æœ¬
    (chunk) => {
      accumulatedPrediction += chunk
      prediction.value = accumulatedPrediction
    },
    // onDone: é¢„æµ‹å®Œæˆ
    () => {
      console.log('[ChatInput] Prediction completed:', accumulatedPrediction)
    }
  )
}, 500)

// è¾“å…¥äº‹ä»¶å¤„ç†
const onInput = () => {
  // ç”¨æˆ·è¾“å…¥æ—¶æ¸…ç©ºé¢„æµ‹
  prediction.value = ''
  
  // è§¦å‘é˜²æŠ–é¢„æµ‹
  debouncedPredict()
  
  // æ›´æ–° textarea ä½ç½®ï¼ˆç”¨äºé¢„æµ‹æ–‡æœ¬è¦†ç›–å±‚å®šä½ï¼‰
  updateTextareaRect()
}

// æ›´æ–° textarea ä½ç½®ä¿¡æ¯
const updateTextareaRect = () => {
  if (textareaRef.value) {
    const rect = textareaRef.value.getBoundingClientRect()
    const scrollTop = textareaRef.value.scrollTop
    textareaRect.value = {
      top: rect.top + window.scrollY - scrollTop,
      left: rect.left + window.scrollX,
      width: rect.width,
      height: rect.height
    }
  }
}

// é”®ç›˜äº‹ä»¶å¤„ç†
const onKeyDown = (event) => {
  // Tab é”®ï¼šæ¥å—é¢„æµ‹
  if (event.key === 'Tab' && prediction.value) {
    event.preventDefault()
    userInput.value += prediction.value
    prediction.value = ''
    return
  }

  // Enter é”®ï¼šå‘é€æ¶ˆæ¯ï¼ˆShift+Enter æ¢è¡Œï¼‰
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault()
    sendMessage()
    return
  }

  // å…¶ä»–æŒ‰é”®ï¼šæ¸…ç©ºé¢„æµ‹
  if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Backspace', 'Delete'].includes(event.key)) {
    prediction.value = ''
  }
}

// ç„¦ç‚¹äº‹ä»¶
const onFocus = () => {
  updateTextareaRect()
}

const onBlur = () => {
  // å¤±ç„¦æ—¶æ¸…ç©ºé¢„æµ‹ï¼ˆé¿å…è¦†ç›–å±‚æ®‹ç•™ï¼‰
  setTimeout(() => {
    prediction.value = ''
  }, 200)
}

// ============ æ–‡æœ¬æ¶¦è‰² ============
// ç›‘å¬ç”¨æˆ·è¾“å…¥ï¼Œæ£€æµ‹å®Œæ•´å¥å­
watch(userInput, debounce(async (newValue) => {
  const trimmed = newValue.trim()
  
  // æ£€æµ‹å®Œæ•´å¥å­ï¼ˆä»¥æ ‡ç‚¹ç¬¦å·ç»“å°¾ï¼‰
  if (trimmed.length > 5 && /[ã€‚ï¼Ÿï¼.?!]$/.test(trimmed)) {
    await fetchPolishOptions(trimmed)
  } else {
    polishOptions.value = []
  }
}, 1000)) // 1ç§’é˜²æŠ–ï¼ˆç”¨æˆ·åœæ­¢è¾“å…¥ 1 ç§’åæ£€æµ‹ï¼‰

// è·å–æ¶¦è‰²é€‰é¡¹
const fetchPolishOptions = async (text) => {
  polishLoading.value = true
  try {
    const contextMessages = store.getters['chat/getRecentMessages'](props.sessionId, 10)
    const response = await polishText({
      user_input: text,
      session_id: props.sessionId,
      context_messages: contextMessages
    })
    
    if (response.data && response.data.options) {
      polishOptions.value = response.data.options
    }
  } catch (error) {
    console.error('[ChatInput] Polish failed:', error)
  } finally {
    polishLoading.value = false
  }
}

// æ¶¦è‰²é€‰é¡¹é€‰æ‹©
const onPolishSelect = (option) => {
  userInput.value = option.text
  polishOptions.value = []  // é€‰æ‹©åéšè—æŒ‰é’®
  
  // èšç„¦è¾“å…¥æ¡†
  nextTick(() => {
    textareaRef.value?.focus()
  })
}

// ============ å‘é€æ¶ˆæ¯ ============
const sendMessage = () => {
  const message = userInput.value.trim()
  if (!message) return

  emit('send', message)
  
  // æ¸…ç©ºè¾“å…¥
  userInput.value = ''
  prediction.value = ''
  polishOptions.value = []
}

// ============ ç”Ÿå‘½å‘¨æœŸ ============
onMounted(async () => {
  // å»ºç«‹ WebSocket è¿æ¥
  const token = store.state.user.accessToken
  try {
    await InputPredictionService.connect(token)
  } catch (error) {
    console.error('[ChatInput] Failed to connect WebSocket:', error)
  }

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œæ›´æ–° textarea ä½ç½®
  window.addEventListener('resize', updateTextareaRect)
})

onBeforeUnmount(() => {
  // æ¸…ç† WebSocket è¿æ¥ï¼ˆç»„ä»¶é”€æ¯æ—¶ï¼‰
  InputPredictionService.disconnect()
  window.removeEventListener('resize', updateTextareaRect)
})
</script>

<style scoped>
.chat-input-wrapper {
  position: relative;
  padding: 16px;
  background: #fff;
  border-top: 1px solid #e4e7ed;
}

.input-container {
  position: relative;
  margin-bottom: 12px;
}

/* å®é™…è¾“å…¥æ¡† */
.message-textarea {
  width: 100%;
  min-height: 60px;
  max-height: 200px;
  padding: 12px;
  border: 1px solid #dcdfe6;
  border-radius: 8px;
  font-size: 14px;
  line-height: 1.5;
  resize: vertical;
  font-family: inherit;
  outline: none;
  transition: border-color 0.2s;
}

.message-textarea:focus {
  border-color: #409eff;
}

/* é¢„æµ‹æ–‡æœ¬è¦†ç›–å±‚ */
.prediction-overlay {
  position: absolute;
  padding: 12px;
  font-size: 14px;
  line-height: 1.5;
  pointer-events: none;  /* ä¸æ‹¦æˆªé¼ æ ‡äº‹ä»¶ï¼Œè®©ç”¨æˆ·èƒ½ç‚¹å‡»ä¸‹æ–¹çš„ textarea */
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow: hidden;
  font-family: inherit;
  z-index: 1;
}

/* ç”¨æˆ·æ–‡æœ¬å ä½ï¼ˆé€æ˜ï¼Œç”¨äºå¯¹é½é¢„æµ‹æ–‡æœ¬ä½ç½®ï¼‰ */
.user-text-placeholder {
  opacity: 0;
}

/* é¢„æµ‹æ–‡æœ¬ï¼ˆåŠé€æ˜ç°è‰²ï¼‰ */
.prediction-text {
  color: #909399;
  opacity: 0.6;
}

/* å‘é€æŒ‰é’® */
.send-button {
  padding: 10px 24px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.2s;
}

.send-button:hover:not(:disabled) {
  background: #66b1ff;
}

.send-button:disabled {
  background: #c0c4cc;
  cursor: not-allowed;
}
</style>
```

### 4.1.1 ä»£ç è§£é‡Šï¼ˆå…³é”®ç‚¹ï¼‰

**ç¬¬ 5-20 è¡Œ**ï¼šé¢„æµ‹æ–‡æœ¬è¦†ç›–å±‚
```vue
<div 
  v-if="prediction" 
  class="prediction-overlay"
  :style="{ 
    top: textareaRect.top + 'px',
    left: textareaRect.left + 'px',
    width: textareaRect.width + 'px',
    height: textareaRect.height + 'px'
  }"
>
  <span class="user-text-placeholder">{{ userInput }}</span>
  <span class="prediction-text">{{ prediction }}</span>
</div>
```
- **å®ç°åŸç†**ï¼š
  1. ä½¿ç”¨ç»å¯¹å®šä½è¦†ç›–å±‚ï¼Œä¸ textarea å®Œå…¨å¯¹é½
  2. `user-text-placeholder` é€æ˜æ˜¾ç¤ºç”¨æˆ·å·²è¾“å…¥æ–‡æœ¬ï¼ˆå ä½ä½œç”¨ï¼Œä½¿é¢„æµ‹æ–‡æœ¬ç´§è·Ÿè¾“å…¥æ–‡æœ¬ï¼‰
  3. `prediction-text` åŠé€æ˜æ˜¾ç¤ºé¢„æµ‹å†…å®¹
- **ä¸ºä»€ä¹ˆä¸ç”¨ placeholderï¼Ÿ**
  - `placeholder` åªåœ¨è¾“å…¥ä¸ºç©ºæ—¶æ˜¾ç¤º
  - éœ€è¦é¢„æµ‹æ–‡æœ¬è·Ÿåœ¨ç”¨æˆ·è¾“å…¥åï¼Œè€Œéæ›¿æ¢æ•´ä¸ªè¾“å…¥

**ç¬¬ 90-121 è¡Œ**ï¼šé˜²æŠ–é¢„æµ‹é€»è¾‘
```javascript
const debouncedPredict = debounce(() => {
  const input = userInput.value.trim()
  
  if (input.length < 2) {
    prediction.value = ''
    return
  }

  const contextMessages = store.getters['chat/getRecentMessages'](props.sessionId, 10)

  let accumulatedPrediction = ''
  InputPredictionService.predict(
    { user_input: input, session_id: props.sessionId, context_messages: contextMessages },
    (chunk) => {
      accumulatedPrediction += chunk
      prediction.value = accumulatedPrediction
    },
    () => { console.log('[ChatInput] Prediction completed:', accumulatedPrediction) }
  )
}, 500)
```
- **é˜²æŠ–é—´éš” 500ms**ï¼šç”¨æˆ·åœæ­¢è¾“å…¥ 500ms åæ‰å‘èµ·é¢„æµ‹ï¼Œé¿å…é¢‘ç¹è¯·æ±‚
- **æœ€å°é•¿åº¦æ£€æŸ¥**ï¼šè¾“å…¥å°‘äº 2 ä¸ªå­—ç¬¦ä¸é¢„æµ‹ï¼ˆæˆæœ¬ä¼˜åŒ–ï¼‰
- **æµå¼æ¥æ”¶**ï¼šé€šè¿‡ `onChunk` å›è°ƒé€æ­¥æ‹¼æ¥é¢„æµ‹æ–‡æœ¬ï¼Œå®ç°æ‰“å­—æœºæ•ˆæœ
- **ä¸Šä¸‹æ–‡è·å–**ï¼šä» Vuex store è·å–æœ€è¿‘ 10 æ¡æ¶ˆæ¯ï¼ˆéœ€åœ¨ store ä¸­å®ç° `getRecentMessages` getterï¼‰

**ç¬¬ 123-145 è¡Œ**ï¼šTab é”®è¡¥å…¨
```javascript
const onKeyDown = (event) => {
  // Tab é”®ï¼šæ¥å—é¢„æµ‹
  if (event.key === 'Tab' && prediction.value) {
    event.preventDefault()
    userInput.value += prediction.value
    prediction.value = ''
    return
  }

  // Enter é”®ï¼šå‘é€æ¶ˆæ¯
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault()
    sendMessage()
    return
  }

  // æ–¹å‘é”®/åˆ é™¤é”®ï¼šæ¸…ç©ºé¢„æµ‹
  if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Backspace', 'Delete'].includes(event.key)) {
    prediction.value = ''
  }
}
```
- **Tab è¡¥å…¨**ï¼šå°†é¢„æµ‹æ–‡æœ¬è¿½åŠ åˆ°ç”¨æˆ·è¾“å…¥å
- **Enter å‘é€**ï¼šä¿ç•™ Shift+Enter æ¢è¡ŒåŠŸèƒ½
- **æ¸…ç©ºé¢„æµ‹**ï¼šç”¨æˆ·ç§»åŠ¨å…‰æ ‡æˆ–åˆ é™¤æ–‡å­—æ—¶æ¸…ç©ºé¢„æµ‹ï¼ˆå› ä¸ºå…‰æ ‡ä½ç½®å˜åŒ–ï¼Œé¢„æµ‹ä¸å†é€‚ç”¨ï¼‰

**ç¬¬ 163-179 è¡Œ**ï¼šæ¶¦è‰²é€‰é¡¹è‡ªåŠ¨æ£€æµ‹
```javascript
watch(userInput, debounce(async (newValue) => {
  const trimmed = newValue.trim()
  
  if (trimmed.length > 5 && /[ã€‚ï¼Ÿï¼.?!]$/.test(trimmed)) {
    await fetchPolishOptions(trimmed)
  } else {
    polishOptions.value = []
  }
}, 1000))
```
- **æ£€æµ‹æ¡ä»¶**ï¼š
  - é•¿åº¦ > 5 ä¸ªå­—ç¬¦ï¼ˆé¿å…å¯¹"ä½ å¥½ã€‚"è¿™ç§çŸ­å¥æ¶¦è‰²ï¼‰
  - ä»¥å¥å·/é—®å·/æ„Ÿå¹å·ç»“å°¾ï¼ˆå®Œæ•´å¥å­æ ‡å¿—ï¼‰
- **é˜²æŠ– 1 ç§’**ï¼šæ¯”é¢„æµ‹æ›´é•¿çš„é˜²æŠ–æ—¶é—´ï¼Œå› ä¸ºæ¶¦è‰²ä¸éœ€è¦å®æ—¶å“åº”

**ç¬¬ 181-199 è¡Œ**ï¼šè·å–æ¶¦è‰²é€‰é¡¹
```javascript
const fetchPolishOptions = async (text) => {
  polishLoading.value = true
  try {
    const contextMessages = store.getters['chat/getRecentMessages'](props.sessionId, 10)
    const response = await polishText({
      user_input: text,
      session_id: props.sessionId,
      context_messages: contextMessages
    })
    
    if (response.data && response.data.options) {
      polishOptions.value = response.data.options
    }
  } catch (error) {
    console.error('[ChatInput] Polish failed:', error)
  } finally {
    polishLoading.value = false
  }
}
```
- **è¿”å›æ•°æ®æ ¼å¼**ï¼š
  ```javascript
  response.data = {
    options: [
      { style: 'æ›´ç¤¼è²Œ', text: 'è¯·é—®æ‚¨ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿ' },
      { style: 'æ›´ç›´æ¥', text: 'ä»Šå¤©æ€ä¹ˆæ ·ï¼Ÿ' }
    ]
  }
  ```
- **é”™è¯¯å¤„ç†**ï¼šé™é»˜å¤±è´¥ï¼Œä¸æ‰“æ‰°ç”¨æˆ·ï¼ˆä»…æ§åˆ¶å°è¾“å‡ºï¼‰

**ç¬¬ 201-210 è¡Œ**ï¼šæ¶¦è‰²é€‰é¡¹é€‰æ‹©
```javascript
const onPolishSelect = (option) => {
  userInput.value = option.text
  polishOptions.value = []
  
  nextTick(() => {
    textareaRef.value?.focus()
  })
}
```
- **æ›¿æ¢è¾“å…¥**ï¼šç›´æ¥ç”¨æ¶¦è‰²åçš„æ–‡æœ¬æ›¿æ¢åŸæ–‡
- **è‡ªåŠ¨èšç„¦**ï¼šä½¿ç”¨ `nextTick` ç¡®ä¿ DOM æ›´æ–°åèšç„¦ï¼ˆç”¨æˆ·å¯ç»§ç»­ç¼–è¾‘ï¼‰

**ç¬¬ 222-232 è¡Œ**ï¼šWebSocket è¿æ¥ç®¡ç†
```javascript
onMounted(async () => {
  const token = store.state.user.accessToken
  try {
    await InputPredictionService.connect(token)
  } catch (error) {
    console.error('[ChatInput] Failed to connect WebSocket:', error)
  }

  window.addEventListener('resize', updateTextareaRect)
})

onBeforeUnmount(() => {
  InputPredictionService.disconnect()
  window.removeEventListener('resize', updateTextareaRect)
})
```
- **è¿æ¥æ—¶æœº**ï¼šç»„ä»¶æŒ‚è½½æ—¶å»ºç«‹ WebSocket
- **æ¸…ç†æ—¶æœº**ï¼šç»„ä»¶é”€æ¯æ—¶æ–­å¼€è¿æ¥ï¼Œé‡Šæ”¾èµ„æº
- **çª—å£ resize ç›‘å¬**ï¼šçª—å£å¤§å°å˜åŒ–æ—¶æ›´æ–°é¢„æµ‹è¦†ç›–å±‚ä½ç½®

---

### 4.2 æ¶¦è‰²æŒ‰é’®ç»„ä»¶

**æ–‡ä»¶è·¯å¾„**: `web/src/components/chat/PolishButtons.vue`ï¼ˆæ–°å»ºï¼‰

```vue
<template>
  <div class="polish-buttons-container">
    <span class="polish-label">æ¶¦è‰²å»ºè®®:</span>
    <el-button
      v-for="option in options"
      :key="option.style"
      size="small"
      type="primary"
      plain
      :loading="loading"
      @click="onSelect(option)"
    >
      {{ option.style }}
    </el-button>
  </div>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue'

const props = defineProps({
  options: {
    type: Array,
    default: () => [],
    // æ¯ä¸ªå…ƒç´ æ ¼å¼: { style: 'æ›´ç¤¼è²Œ', text: 'æ¶¦è‰²åçš„æ–‡æœ¬' }
  },
  loading: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['select'])

const onSelect = (option) => {
  emit('select', option)
}
</script>

<style scoped>
.polish-buttons-container {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px 12px;
  background: #f5f7fa;
  border-radius: 6px;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.polish-label {
  font-size: 13px;
  color: #606266;
  font-weight: 500;
}

.el-button {
  transition: all 0.2s;
}

.el-button:hover {
  transform: translateY(-2px);
}
</style>
```

### 4.2.1 ä»£ç è§£é‡Š

**ç¬¬ 2-15 è¡Œ**ï¼šæŒ‰é’®æ¸²æŸ“
```vue
<el-button
  v-for="option in options"
  :key="option.style"
  size="small"
  type="primary"
  plain
  :loading="loading"
  @click="onSelect(option)"
>
  {{ option.style }}
</el-button>
```
- **v-for éå†**ï¼šåŠ¨æ€æ¸²æŸ“æ¶¦è‰²é€‰é¡¹ï¼ˆé€šå¸¸ 2-3 ä¸ªæŒ‰é’®ï¼‰
- **plain å±æ€§**ï¼šä½¿ç”¨ Element Plus çš„æœ´ç´ æŒ‰é’®æ ·å¼ï¼ˆè¾¹æ¡†æ ·å¼ï¼Œéå®å¿ƒï¼‰
- **loading çŠ¶æ€**ï¼šè¯·æ±‚ API æ—¶æ˜¾ç¤ºåŠ è½½åŠ¨ç”»

**ç¬¬ 44-62 è¡Œ**ï¼šæ»‘å…¥åŠ¨ç”»
```css
animation: slideDown 0.3s ease-out;

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
```
- **è§†è§‰åé¦ˆ**ï¼šæ¶¦è‰²é€‰é¡¹å‡ºç°æ—¶ä»ä¸Šæ–¹æ»‘å…¥ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
- **åŠ¨ç”»æ—¶é•¿**ï¼š300msï¼Œå¿«é€Ÿä½†ä¸çªå…€

---

### 4.3 æ‘˜è¦å¡ç‰‡ç»„ä»¶

**æ–‡ä»¶è·¯å¾„**: `web/src/components/chat/DigestCard.vue`ï¼ˆæ–°å»ºï¼‰

```vue
<template>
  <div class="digest-card" v-if="visible">
    <!-- å¡ç‰‡å¤´éƒ¨ -->
    <div class="digest-header">
      <span class="digest-title">ğŸ“ æ¶ˆæ¯æ‘˜è¦ ({{ messageCount }} æ¡)</span>
      <el-button 
        text 
        size="small" 
        @click="onClose"
      >
        å…³é—­
      </el-button>
    </div>

    <!-- æ‘˜è¦å†…å®¹ -->
    <div class="digest-content" v-loading="loading">
      <div v-if="summary" v-html="renderedSummary" class="markdown-body"></div>
      <div v-else-if="!loading" class="empty-state">
        æš‚æ— æ‘˜è¦å†…å®¹
      </div>
    </div>

    <!-- æ“ä½œæŒ‰é’® -->
    <div class="digest-footer">
      <el-button size="small" @click="onRefresh">
        åˆ·æ–°æ‘˜è¦
      </el-button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { marked } from 'marked'  // éœ€å®‰è£…: npm install marked
import DOMPurify from 'dompurify'  // éœ€å®‰è£…: npm install dompurify
import { digestMessages } from '@/api/aiMicroservice'
import { ElMessage } from 'element-plus'

const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  sessionId: {
    type: String,
    required: true
  },
  messages: {
    type: Array,
    default: () => [],
    // æ¯ä¸ªå…ƒç´ æ ¼å¼: { sender: string, content: string, timestamp: number }
  }
})

const emit = defineEmits(['close'])

// ============ çŠ¶æ€ç®¡ç† ============
const loading = ref(false)
const summary = ref('')
const messageCount = computed(() => props.messages.length)

// Markdown æ¸²æŸ“ï¼ˆä½¿ç”¨ marked + DOMPurify é˜²æ­¢ XSSï¼‰
const renderedSummary = computed(() => {
  if (!summary.value) return ''
  const html = marked.parse(summary.value)
  return DOMPurify.sanitize(html)
})

// ============ è·å–æ‘˜è¦ ============
const fetchDigest = async () => {
  if (props.messages.length < 50) {
    ElMessage.warning('æ¶ˆæ¯æ•°é‡å°‘äº 50 æ¡ï¼Œæ— éœ€æ‘˜è¦')
    return
  }

  loading.value = true
  try {
    const response = await digestMessages({
      session_id: props.sessionId,
      messages: props.messages,
      max_messages: 200
    })
    
    if (response.data && response.data.summary) {
      summary.value = response.data.summary
    }
  } catch (error) {
    console.error('[DigestCard] Digest failed:', error)
    ElMessage.error('æ‘˜è¦ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
  } finally {
    loading.value = false
  }
}

// ============ äº‹ä»¶å¤„ç† ============
const onClose = () => {
  emit('close')
}

const onRefresh = () => {
  summary.value = ''
  fetchDigest()
}

// ============ ç›‘å¬å™¨ ============
// å¡ç‰‡æ˜¾ç¤ºæ—¶è‡ªåŠ¨è·å–æ‘˜è¦
watch(() => props.visible, (newValue) => {
  if (newValue && !summary.value) {
    fetchDigest()
  }
})
</script>

<style scoped>
.digest-card {
  position: sticky;
  top: 60px;
  margin: 16px;
  padding: 16px;
  background: #fff;
  border: 1px solid #e4e7ed;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  max-height: 500px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.digest-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid #e4e7ed;
}

.digest-title {
  font-size: 16px;
  font-weight: 600;
  color: #303133;
}

.digest-content {
  flex: 1;
  overflow-y: auto;
  min-height: 200px;
  max-height: 400px;
  padding: 12px 0;
}

/* Markdown æ ·å¼ï¼ˆåŸºäº GitHub é£æ ¼ï¼‰ */
.markdown-body {
  font-size: 14px;
  line-height: 1.6;
  color: #24292e;
}

.markdown-body h2 {
  font-size: 16px;
  font-weight: 600;
  margin: 12px 0 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid #eaecef;
}

.markdown-body ul {
  padding-left: 24px;
  margin: 8px 0;
}

.markdown-body li {
  margin: 4px 0;
}

.markdown-body strong {
  font-weight: 600;
  color: #409eff;
}

.empty-state {
  text-align: center;
  color: #909399;
  padding: 40px 0;
}

.digest-footer {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #e4e7ed;
  text-align: right;
}
</style>
```

### 4.3.1 ä»£ç è§£é‡Š

**ç¬¬ 16-18 è¡Œ**ï¼šMarkdown æ¸²æŸ“
```vue
<div v-if="summary" v-html="renderedSummary" class="markdown-body"></div>
```
- **ä½¿ç”¨ marked åº“**ï¼šå°†åç«¯è¿”å›çš„ Markdown æ ¼å¼æ‘˜è¦è½¬æ¢ä¸º HTML
- **ä½¿ç”¨ DOMPurify**ï¼šé˜²æ­¢ XSS æ”»å‡»ï¼ˆåç«¯å¯èƒ½è¿”å›æ¶æ„è„šæœ¬ï¼‰
- **å®‰è£…ä¾èµ–**ï¼š
  ```bash
  npm install marked dompurify
  ```

**ç¬¬ 62-67 è¡Œ**ï¼šMarkdown æ¸²æŸ“è®¡ç®—å±æ€§
```javascript
const renderedSummary = computed(() => {
  if (!summary.value) return ''
  const html = marked.parse(summary.value)
  return DOMPurify.sanitize(html)
})
```
- **marked.parse()**ï¼šMarkdown â†’ HTML
- **DOMPurify.sanitize()**ï¼šç§»é™¤å±é™©æ ‡ç­¾ï¼ˆå¦‚ `<script>`, `<iframe>`ï¼‰

**ç¬¬ 70-91 è¡Œ**ï¼šè·å–æ‘˜è¦
```javascript
const fetchDigest = async () => {
  if (props.messages.length < 50) {
    ElMessage.warning('æ¶ˆæ¯æ•°é‡å°‘äº 50 æ¡ï¼Œæ— éœ€æ‘˜è¦')
    return
  }

  loading.value = true
  try {
    const response = await digestMessages({
      session_id: props.sessionId,
      messages: props.messages,
      max_messages: 200
    })
    
    if (response.data && response.data.summary) {
      summary.value = response.data.summary
    }
  } catch (error) {
    console.error('[DigestCard] Digest failed:', error)
    ElMessage.error('æ‘˜è¦ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
  } finally {
    loading.value = false
  }
}
```
- **é˜ˆå€¼æ£€æŸ¥**ï¼šå°‘äº 50 æ¡æ¶ˆæ¯æ—¶æç¤ºç”¨æˆ·æ— éœ€æ‘˜è¦
- **æœ€å¤§æ¶ˆæ¯æ•°**ï¼šä¼ é€’ `max_messages: 200` é™åˆ¶å¤„ç†é‡ï¼ˆé¿å…è¶…å‡ºæ¨¡å‹ä¸Šä¸‹æ–‡çª—å£ï¼‰

**ç¬¬ 107-112 è¡Œ**ï¼šè‡ªåŠ¨åŠ è½½æ‘˜è¦
```javascript
watch(() => props.visible, (newValue) => {
  if (newValue && !summary.value) {
    fetchDigest()
  }
})
```
- **è§¦å‘æ—¶æœº**ï¼šå¡ç‰‡ä»éšè—å˜ä¸ºæ˜¾ç¤ºæ—¶
- **é¿å…é‡å¤è¯·æ±‚**ï¼šå·²æœ‰æ‘˜è¦æ—¶ä¸é‡æ–°è·å–ï¼ˆé™¤éç”¨æˆ·ç‚¹å‡»"åˆ·æ–°æ‘˜è¦"ï¼‰

**ç¬¬ 171-193 è¡Œ**ï¼šMarkdown æ ·å¼
```css
.markdown-body h2 {
  font-size: 16px;
  font-weight: 600;
  margin: 12px 0 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid #eaecef;
}
```
- **ä»¿ GitHub é£æ ¼**ï¼šæ¸…æ™°çš„æ ‡é¢˜ã€åˆ—è¡¨ã€å¼ºè°ƒæ ·å¼
- **è‡ªå®šä¹‰è°ƒæ•´**ï¼šé¢œè‰²ã€å­—å·é€‚é…é¡¹ç›®æ•´ä½“è®¾è®¡

---

## 5. çŠ¶æ€ç®¡ç†

### 5.1 Vuex æ¨¡å—

**æ–‡ä»¶è·¯å¾„**: `web/src/store/modules/aiMicroservice.js`ï¼ˆæ–°å»ºï¼‰

```javascript
/**
 * AI å¾®æœåŠ¡çŠ¶æ€ç®¡ç†
 * ç®¡ç†ï¼šWebSocket è¿æ¥çŠ¶æ€ã€æ¶¦è‰²ç¼“å­˜ã€æ‘˜è¦ç¼“å­˜ç­‰
 */

const state = {
  wsConnected: false,          // WebSocket è¿æ¥çŠ¶æ€
  polishCache: new Map(),      // æ¶¦è‰²ç»“æœç¼“å­˜ï¼ˆkey: input_text, value: optionsï¼‰
  digestCache: new Map(),      // æ‘˜è¦ç»“æœç¼“å­˜ï¼ˆkey: session_id, value: summaryï¼‰
}

const getters = {
  isWsConnected: state => state.wsConnected,
  
  getPolishCache: state => (text) => {
    return state.polishCache.get(text) || null
  },
  
  getDigestCache: state => (sessionId) => {
    return state.digestCache.get(sessionId) || null
  }
}

const mutations = {
  SET_WS_CONNECTED(state, connected) {
    state.wsConnected = connected
  },
  
  SET_POLISH_CACHE(state, { text, options }) {
    state.polishCache.set(text, options)
  },
  
  SET_DIGEST_CACHE(state, { sessionId, summary }) {
    state.digestCache.set(sessionId, summary)
  },
  
  CLEAR_POLISH_CACHE(state) {
    state.polishCache.clear()
  },
  
  CLEAR_DIGEST_CACHE(state) {
    state.digestCache.clear()
  }
}

const actions = {
  updateWsStatus({ commit }, connected) {
    commit('SET_WS_CONNECTED', connected)
  },
  
  cachePolishResult({ commit }, payload) {
    commit('SET_POLISH_CACHE', payload)
  },
  
  cacheDigestResult({ commit }, payload) {
    commit('SET_DIGEST_CACHE', payload)
  }
}

export default {
  namespaced: true,
  state,
  getters,
  mutations,
  actions
}
```

### 5.2 æ³¨å†Œæ¨¡å—

**æ–‡ä»¶è·¯å¾„**: `web/src/store/index.js`ï¼ˆä¿®æ”¹ï¼‰

```javascript
import { createStore } from 'vuex'
import user from './modules/user'
import chat from './modules/chat'
import aiMicroservice from './modules/aiMicroservice'  // æ–°å¢

export default createStore({
  modules: {
    user,
    chat,
    aiMicroservice  // æ–°å¢
  }
})
```

### 5.3 ä½¿ç”¨ç¤ºä¾‹

```javascript
// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
import { useStore } from 'vuex'

const store = useStore()

// æ›´æ–° WebSocket çŠ¶æ€
InputPredictionService.connect(token).then(() => {
  store.dispatch('aiMicroservice/updateWsStatus', true)
})

// ç¼“å­˜æ¶¦è‰²ç»“æœ
const polishOptions = await polishText({ user_input: 'ä½ å¥½' })
store.dispatch('aiMicroservice/cachePolishResult', {
  text: 'ä½ å¥½',
  options: polishOptions
})

// è¯»å–ç¼“å­˜
const cached = store.getters['aiMicroservice/getPolishCache']('ä½ å¥½')
if (cached) {
  // ä½¿ç”¨ç¼“å­˜ç»“æœï¼Œæ— éœ€è°ƒç”¨ API
}
```

---

## 6. æ ·å¼è®¾è®¡

### 6.1 è®¾è®¡åŸåˆ™

| åŸåˆ™ | å®ç° |
|------|------|
| **éä¾µå…¥æ€§** | é¢„æµ‹æ–‡æœ¬åŠé€æ˜æ˜¾ç¤ºï¼Œä¸å¹²æ‰°ç”¨æˆ·è¾“å…¥ |
| **å³æ—¶åé¦ˆ** | WebSocket æµå¼è¾“å‡ºï¼Œæ‰“å­—æœºæ•ˆæœ |
| **ä¼˜é›…é™çº§** | WebSocket è¿æ¥å¤±è´¥æ—¶éšè—é¢„æµ‹åŠŸèƒ½ |
| **æ— éšœç¢** | é”®ç›˜å¿«æ·é”®ï¼ˆTab è¡¥å…¨ã€Enter å‘é€ï¼‰ |
| **å“åº”å¼** | é€‚é…ç§»åŠ¨ç«¯è§¦æ‘¸æ“ä½œ |

### 6.2 é¢œè‰²è§„èŒƒ

```css
/* ä¸»é¢˜è‰²ï¼ˆElement Plus é»˜è®¤ï¼‰ */
--primary-color: #409eff;
--success-color: #67c23a;
--warning-color: #e6a23c;
--danger-color: #f56c6c;

/* æ–‡æœ¬è‰² */
--text-primary: #303133;
--text-regular: #606266;
--text-secondary: #909399;
--text-placeholder: #c0c4cc;

/* è¾¹æ¡†è‰² */
--border-base: #dcdfe6;
--border-light: #e4e7ed;

/* èƒŒæ™¯è‰² */
--bg-white: #ffffff;
--bg-light: #f5f7fa;

/* AI åŠŸèƒ½ä¸“ç”¨è‰² */
--prediction-text: #909399;    /* é¢„æµ‹æ–‡æœ¬é¢œè‰² */
--polish-bg: #f5f7fa;          /* æ¶¦è‰²æŒ‰é’®åŒºåŸŸèƒŒæ™¯ */
--digest-border: #e4e7ed;      /* æ‘˜è¦å¡ç‰‡è¾¹æ¡† */
```

### 6.3 åŠ¨ç”»æ•ˆæœ

```css
/* æ»‘å…¥åŠ¨ç”»ï¼ˆæ¶¦è‰²æŒ‰é’®ï¼‰ */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* æ·¡å…¥åŠ¨ç”»ï¼ˆæ‘˜è¦å¡ç‰‡ï¼‰ */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* æ‚¬æµ®åŠ¨ç”»ï¼ˆæŒ‰é’®ï¼‰ */
.hover-lift {
  transition: transform 0.2s ease;
}

.hover-lift:hover {
  transform: translateY(-2px);
}
```

---

## 7. æµ‹è¯•æ–¹æ¡ˆ

### 7.1 å•å…ƒæµ‹è¯•

**æµ‹è¯•æ–‡ä»¶**: `web/tests/unit/InputPredictionService.spec.js`

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import InputPredictionService from '@/services/InputPredictionService'

describe('InputPredictionService', () => {
  beforeEach(() => {
    // é‡ç½® WebSocket çŠ¶æ€
    InputPredictionService.disconnect()
  })

  it('should connect to WebSocket with token', async () => {
    const token = 'test_token_123'
    
    // Mock WebSocket
    global.WebSocket = vi.fn().mockImplementation((url) => {
      expect(url).toContain(token)
      return {
        readyState: WebSocket.OPEN,
        onopen: null,
        onmessage: null,
        onclose: null,
        onerror: null,
        send: vi.fn(),
        close: vi.fn()
      }
    })

    await InputPredictionService.connect(token)
    expect(InputPredictionService.isConnected).toBe(true)
  })

  it('should handle streaming prediction', (done) => {
    const mockChunks = ['ä½ å¥½', 'ï¼Œæœ‰ä»€ä¹ˆ', 'å¯ä»¥å¸®åŠ©ä½ çš„ï¼Ÿ']
    let receivedChunks = []

    InputPredictionService.predict(
      { user_input: 'ä½ å¥½', session_id: 'test', context_messages: [] },
      (chunk) => {
        receivedChunks.push(chunk)
      },
      () => {
        expect(receivedChunks).toEqual(mockChunks)
        done()
      }
    )

    // æ¨¡æ‹ŸæœåŠ¡ç«¯å‘é€æ¶ˆæ¯
    mockChunks.forEach(chunk => {
      InputPredictionService.ws.onmessage({
        data: JSON.stringify({ chunk })
      })
    })
    InputPredictionService.ws.onmessage({
      data: JSON.stringify({ done: true })
    })
  })
})
```

### 7.2 ç»„ä»¶æµ‹è¯•

**æµ‹è¯•æ–‡ä»¶**: `web/tests/unit/ChatInput.spec.js`

```javascript
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import ChatInput from '@/components/chat/ChatInput.vue'

describe('ChatInput.vue', () => {
  it('should show prediction overlay on input', async () => {
    const wrapper = mount(ChatInput, {
      props: { sessionId: 'test_session' }
    })

    const textarea = wrapper.find('textarea')
    await textarea.setValue('ä½ å¥½')

    // ç­‰å¾…é˜²æŠ–
    await new Promise(resolve => setTimeout(resolve, 600))

    // æ£€æŸ¥é¢„æµ‹è¦†ç›–å±‚
    expect(wrapper.find('.prediction-overlay').exists()).toBe(true)
  })

  it('should accept prediction on Tab key', async () => {
    const wrapper = mount(ChatInput, {
      props: { sessionId: 'test_session' }
    })

    wrapper.vm.userInput = 'ä½ å¥½'
    wrapper.vm.prediction = 'ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ çš„ï¼Ÿ'

    const textarea = wrapper.find('textarea')
    await textarea.trigger('keydown', { key: 'Tab' })

    expect(wrapper.vm.userInput).toBe('ä½ å¥½ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©ä½ çš„ï¼Ÿ')
    expect(wrapper.vm.prediction).toBe('')
  })
})
```

### 7.3 E2E æµ‹è¯•

**æµ‹è¯•æ–‡ä»¶**: `web/tests/e2e/ai-microservice.spec.js`ï¼ˆä½¿ç”¨ Playwrightï¼‰

```javascript
import { test, expect } from '@playwright/test'

test('æ™ºèƒ½è¾“å…¥é¢„æµ‹å®Œæ•´æµç¨‹', async ({ page }) => {
  // 1. ç™»å½•
  await page.goto('http://localhost:8080/login')
  await page.fill('input[name="username"]', 'testuser')
  await page.fill('input[name="password"]', 'password')
  await page.click('button[type="submit"]')

  // 2. è¿›å…¥èŠå¤©é¡µé¢
  await page.goto('http://localhost:8080/chat/session_123')

  // 3. è¾“å…¥æ–‡æœ¬
  const textarea = page.locator('.message-textarea')
  await textarea.fill('ä½ å¥½')

  // 4. ç­‰å¾…é¢„æµ‹å‡ºç°
  await page.waitForSelector('.prediction-text', { timeout: 3000 })

  // 5. éªŒè¯é¢„æµ‹æ–‡æœ¬
  const prediction = await page.locator('.prediction-text').textContent()
  expect(prediction.length).toBeGreaterThan(0)

  // 6. æŒ‰ Tab æ¥å—é¢„æµ‹
  await textarea.press('Tab')

  // 7. éªŒè¯æ–‡æœ¬å·²è¡¥å…¨
  const finalValue = await textarea.inputValue()
  expect(finalValue).toContain(prediction)
})

test('æ–‡æœ¬æ¶¦è‰²å®Œæ•´æµç¨‹', async ({ page }) => {
  await page.goto('http://localhost:8080/chat/session_123')

  const textarea = page.locator('.message-textarea')
  await textarea.fill('ä»Šå¤©å¤©æ°”ä¸é”™ã€‚')

  // ç­‰å¾…æ¶¦è‰²æŒ‰é’®å‡ºç°
  await page.waitForSelector('.polish-buttons-container', { timeout: 2000 })

  // ç‚¹å‡»ç¬¬ä¸€ä¸ªæ¶¦è‰²é€‰é¡¹
  await page.locator('.polish-buttons-container .el-button').first().click()

  // éªŒè¯æ–‡æœ¬å·²æ›¿æ¢
  const newValue = await textarea.inputValue()
  expect(newValue).not.toBe('ä»Šå¤©å¤©æ°”ä¸é”™ã€‚')
})
```

---

## 8. æ€»ç»“ä¸ä¸‹ä¸€æ­¥

### 8.1 æœ¬éƒ¨åˆ†å®Œæˆå†…å®¹

| æ¨¡å— | æ–‡ä»¶ | è¡Œæ•° | çŠ¶æ€ |
|------|------|------|------|
| API æœåŠ¡å±‚ | `aiMicroservice.js` | ~60 | âœ… |
| WebSocket æœåŠ¡ | `InputPredictionService.js` | ~180 | âœ… |
| æ™ºèƒ½è¾“å…¥ç»„ä»¶ | `ChatInput.vue` | ~280 | âœ… |
| æ¶¦è‰²æŒ‰é’®ç»„ä»¶ | `PolishButtons.vue` | ~75 | âœ… |
| æ‘˜è¦å¡ç‰‡ç»„ä»¶ | `DigestCard.vue` | ~200 | âœ… |
| Vuex çŠ¶æ€ç®¡ç† | `aiMicroservice.js` | ~65 | âœ… |
| **æ€»è®¡** | **6 ä¸ªæ–‡ä»¶** | **~860 è¡Œ** | **âœ…** |

### 8.2 å¾…é›†æˆå·¥ä½œ

1. **èŠå¤©è®°å½•è·å–**ï¼ˆéœ€åœ¨ Vuex chat æ¨¡å—ä¸­å®ç°ï¼‰ï¼š
   ```javascript
   // store/modules/chat.js
   getters: {
     getRecentMessages: (state) => (sessionId, count) => {
       const session = state.sessions[sessionId]
       return session?.messages.slice(-count) || []
     }
   }
   ```

2. **JWT Token ç®¡ç†**ï¼ˆéœ€åœ¨ Vuex user æ¨¡å—ä¸­å®ç°ï¼‰ï¼š
   ```javascript
   // store/modules/user.js
   state: {
     accessToken: localStorage.getItem('access_token') || ''
   }
   ```

3. **Axios è¯·æ±‚æ‹¦æˆªå™¨**ï¼ˆéœ€åœ¨ `utils/request.js` ä¸­é…ç½®ï¼‰ï¼š
   ```javascript
   import axios from 'axios'
   
   const request = axios.create({
     baseURL: process.env.VUE_APP_API_BASE_URL
   })
   
   request.interceptors.request.use(config => {
     const token = localStorage.getItem('access_token')
     if (token) {
       config.headers.Authorization = `Bearer ${token}`
     }
     return config
   })
   
   export default request
   ```

### 8.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è™šæ‹Ÿæ»šåŠ¨**ï¼ˆæ¶ˆæ¯æ‘˜è¦å¡ç‰‡å†…å®¹è¿‡é•¿æ—¶ï¼‰ï¼š
   ```javascript
   // ä½¿ç”¨ vue-virtual-scroller
   npm install vue-virtual-scroller
   ```

2. **Web Worker**ï¼ˆMarkdown æ¸²æŸ“ç§»åˆ°åå°çº¿ç¨‹ï¼‰ï¼š
   ```javascript
   // workers/markdown.worker.js
   import { marked } from 'marked'
   self.onmessage = (e) => {
     const html = marked.parse(e.data)
     self.postMessage(html)
   }
   ```

3. **æ‡’åŠ è½½**ï¼ˆæ‘˜è¦å¡ç‰‡ç»„ä»¶æŒ‰éœ€åŠ è½½ï¼‰ï¼š
   ```javascript
   const DigestCard = defineAsyncComponent(() =>
     import('./components/chat/DigestCard.vue')
   )
   ```

### 8.4 ä¸‹ä¸€æ­¥

1. **Part 8: æµ‹è¯•ä¸éªŒè¯**
   - å•å…ƒæµ‹è¯•ï¼ˆVitest + @vue/test-utilsï¼‰
   - E2E æµ‹è¯•ï¼ˆPlaywrightï¼‰
   - æ€§èƒ½æµ‹è¯•ï¼ˆWebSocket å¹¶å‘å‹æµ‹ï¼‰

2. **Part 9: éƒ¨ç½²ä¸ç›‘æ§**
   - Docker å®¹å™¨åŒ–
   - Nginx é…ç½®ï¼ˆWebSocket ä»£ç†ï¼‰
   - Prometheus æŒ‡æ ‡åŸ‹ç‚¹
   - Grafana ä»ªè¡¨æ¿

---

**æ–‡æ¡£ç»“æŸ** | ä¸‹ä¸€æ­¥ï¼š[Part 8 - æµ‹è¯•ä¸éªŒè¯](./æ¨¡å—ä¸‰_è¶…è¯¦ç»†å®æ–½æŒ‡å—_ç¬¬8éƒ¨åˆ†_æµ‹è¯•ä¸éªŒè¯.md)
